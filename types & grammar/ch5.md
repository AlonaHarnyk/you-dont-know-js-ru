# Вы не знаете JS: Типы и грамматика
# Глава 5: Грамматика

Последняя важная тема, которую мы хотим затронуть, - это то, как работает синтаксис языка JavaScript (он же его грамматика). Вы можете думать, что знаете, как писать JS, но в различных частях грамматики языка ужасно много нюансов, которые приводят к путанице и неправильному пониманию, поэтому мы хотим углубиться в эти части и прояснить некоторые вещи.

**Примечание:** Термин "грамматика" может быть немного менее знаком читателям, чем термин "синтаксис". Во многих отношениях это схожие термины, описывающие *правила* того, как работает язык. У них есть небольшие различия, но они в основном не имеют значения для нашего здесь обсуждения. Грамматика для JavaScript - это структурированный способ описания того, как синтаксис (операторы, ключевые слова и т.д.) компонуется в правильно и корректно разработанные программы. Иными словами, обсуждение синтаксиса без грамматики упустило бы многие важные детали. Поэтому, в этой главе наше внимание акцентируется на том, что наиболее точно описывается как "грамматика", хотя разработчики непосредственно оперируют с синтаксисом языка.

## Инструкции и выражения

Разработчики довольно часто предполагают, что термины "инструкция" и "выражение" примерно эквивалентны. Но здесь нам нужно разделить их, потому что в наших JS программах есть некоторые очень важные различия.

Чтобы провести различие, давайте позаимствуем терминологию, с которой вы, возможно, более знакомы: английский язык.

"Предложение" - это одно законченное высказывание из слов, выражающее мысль. Оно состоит из одной или нескольких "фраз", каждая из которых может быть связана знаками препинания или союзами ("и", "или" и т.д.). Сама фраза может состоять из более мелких фраз. Некоторые фразы являются неполными и сами по себе мало чего значат, в то время как другие фразы могут быть самостоятельными. Эти правила в совокупности называются *грамматикой* английского языка.

Так же обстоит дело с грамматикой JavaScript. Инструкции - это предложения, выражения - это фразы, а операторы - это союзы/знаки препинания.

Каждое выражение в JS может быть вычислено вплоть до одного конкретного значения. Например:

```js
var a = 3 * 6;
var b = a;
b;
```

В этом фрагменте `3 * 6` является выражением (вычисляется до значения `18`). `a` во второй строке также является выражением, как и `b` в третьей строке. Оба выражения `a` и `b` вычисляются в соответствии со значениями, хранящимися в этих переменных в данный момент, которые равны `18`.

Более того, каждая из трех строк представляет собой инструкцию, содержащую выражения. `var a = 3 * 6` и `var b = a` называются "операторами объявления", потому что каждый из них объявляет переменную (и необязательно присваивает ей значение). Присваивания `a = 3 * 6` и `b = a` (откидывая `var`) называются выражениями присваивания.

Третья строка содержит только выражение `b`, и это также инструкция сама по себе (хотя и не очень интересная!). Обычно это называется "оператор выражения".

### Значение завершения инструкции

Это весьма малоизвестный факт, что все инструкции имеют значения завершения (даже если это просто `undefined`).

Как бы вы отнеслись к тому, чтобы взглянуть на значение завершения?

Наиболее очевидный путь - ввести инструкцию в консоль разработчика вашего браузера, потому что, когда вы ее выполняете, консоль по умолчанию сообщает значение завершения самой последней инструкции, которую она выполнила.

Давайте рассмотрим `var b = a`. Каково значение завершения этой инструкции?

Выражение присваивания `b = a` возвращает значение, которое было присвоено (`18` см. выше), но сама инструкция `var` возвращает `undefined`. Почему? Потому что так инструкция `var` определена в спецификации. Если вы введете `var a = 42;` в свою консоль, вы увидите сообщение `undefined` вместо `42`.

**Примечание:** Технически всё немного сложнее. В спецификации ES5, раздел 12.2 "Инструкция переменной", алгоритм `VariableDeclaration` действительно *возвращает* значение (`string`, содержащая имя объявленной переменной - странно, да!?), но это значение обычно поглощается (кроме цикла `for..in`) алгоритмом `VariableStatement`, который выдает пустое (известное как `undefined`) значение завершения.

На самом деле, если вы много экспериментировали с кодом в своей консоли (или в JS среде REPL -- read /evaluate /print / loop), вы, вероятно, видели сообщение `undefined` после множества разных инструкций и, возможно, никогда не понимали, что бы это было. Проще говоря, консоль просто сообщает значение завершения инструкции.

Но то, что консоль выводит как значение завершения, - это не то, что мы можем использовать внутри нашей программы. Итак, как мы можем зафиксировать значение завершения?

Это гораздо более сложная задача. Прежде чем мы объясним *как*, давайте рассмотрим *почему* вам хотелось бы это сделать?

Нам нужно рассмотреть другие типы значений завершения инструкции. Например, любой обыденный блок `{ .. }` имеет значение завершения, равное значению завершения его последней инструкции/выражения.

Рассмотрим:

```js
var b;

if (true) {
	b = 4 + 38;
}
```

Если бы вы ввели это в своей REPL-консоли, вы, вероятно, увидели бы сообщение `42`, поскольку `42` - это значение завершения блока `if`, который принял значение завершения своей последней инструкции выражения присваивания `b = 4 + 38`.

Другими словами, значение завершения блока похоже на *неявный return* значения последней инструкции в блоке.

**Примечание:** Это концептуально известно в таких языках, как CoffeeScript, которые имеют неявные `return` значения из `function`, которые совпадают со значением последней инструкции в функции.

Но есть очевидная проблема. Такой код не работает:

```js
var a, b;

a = if (true) {
	b = 4 + 38;
};
```

Мы не можем зафиксировать значение завершения инструкции и присвоить его другой переменной каким-либо простым синтаксическим/грамматическим способом (по крайней мере, пока!).

Итак, что мы можем сделать?

**Предупреждение**: только для демонстрационных целей -- пожалуйста, не делайте нижеприведенное в вашем реальном коде!

Мы можем использовать сильно оклеветанную функцию `eval(..)` (иногда произносится как "evil" - "злой"), чтобы зафиксировать это значение завершения.

```js
var a, b;

a = eval( "if (true) { b = 4 + 38; }" );

a;	// 42
```

Дааааааааа. Это ужасно некрасиво. Но это работает! И это иллюстрирует тот факт, что значения завершения инструкции - это реальная вещь, которая может быть зафиксирована не только в нашей консоли, но и в наших программах.

Есть предложение для ES7 под названием "выражение исполнения" (do-выражение). Вот как это может сработать:

```js
var a, b;

a = do {
	if (true) {
		b = 4 + 38;
	}
};

a;	// 42
```

Выражение `do { .. }` выполняет блок (с одним или несколькими операторами в нем), и значение завершения последней инструкции внутри блока становится значением завершения *`do`-выражения*, которое, как показано, затем может быть присвоено `a`.

Общая идея состоит в том, чтобы иметь возможность обрабатывать инструкции как выражения -- они могут отображаться внутри других инструкций -- без необходимости оборачивать их в функциональные выражения и делать явный `return ..`.

На данный момент значения завершения инструкций - это не больше, чем пустяки. Но они, возможно, будут приобретать все большее значение по мере развития JS, и, надеюсь, выражения `do { .. }` уменьшат соблазн использовать такие вещи, как `eval (..)`.

**Предупреждение:** Повторяю мое предыдущее увещевание: избегайте `eval (..)`. Серьезно. За дополнительными деталями обращайтесь к книге этой же серии *Область Видимости и Замыкания*.

### Побочные эффекты выражений

Большинство выражений не имеют побочных эффектов. Например:

```js
var a = 2;
var b = a + 3;
```

Выражение `a + 3` не имело *собственного* побочного эффекта, как, например, изменение `a`. У него был результат, равный `5`, и этот итог был присвоен `b` в инструкции `b = a + 3`.

Наиболее распространенным примером выражения с (возможными) побочными эффектами является выражение вызова функции:

```js
function foo() {
	a = a + 1;
}

var a = 1;
foo();		// результат: `undefined`, сторонний эффект: изменённое `a`
```

Однако есть и другие побочные эффекты выражений. Например:

```js
var a = 42;
var b = a++;
```

Выражение `a++` выполняет два отдельных действия. *Сначала* оно возвращает текущее значение `a`, которое равно `42` (которое следом присваивается `b`). Но *затем* оно изменяет само значение `a`, увеличивая его на единицу.

```js
var a = 42;
var b = a++;

a;	// 43
b;	// 42
```

Многие разработчики ошибочно полагают, что `b` равно `43` так же, как и `a`. Неразбериха возникает из-за того, что не полностью учитывается, *когда* происходит побочный эффект оператора `++`.

Операторы инкремента `++` и оператор декремента `--` являются унарными операторами (см. Главу 4), которые могут использоваться либо в постфиксной ("после") позиции, либо в префиксной ("до") позиции.

```js
var a = 42;

a++;	// 42
a;		// 43

++a;	// 44
a;		// 44
```

Когда `++` используется в префиксной позиции, как в `++a`, его побочный эффект (увеличение `a` на единицу) происходит *до* возврата значения из выражения, а не *после*, как в случае `a++`.

**Примечание:** Считаете ли вы, что `++a++` - это корректный синтаксис? Если вы попробуете, то получите ошибку `ReferenceError`, но почему? Потому что операторы с побочным эффектом **требуют ссылки на переменную**, на которую нацелены их побочные эффекты. Для `++a++` сначала вычисляется часть `a++` (из-за приоритета оператора - см. ниже), которая возвращает значение `a` _до_ инкремента. Но затем он пытается вычислить `++42`, что (если вы попытаетесь это сделать) даст ту же ошибку `ReferenceError`, поскольку `++` не может иметь побочного эффекта непосредственно для значения `42`.

Иногда ошибочно полагают, что вы можете инкапсулировать побочный эффект *после* `a++`, заключив его в пару скобок `( )`, например:

```js
var a = 42;
var b = (a++);

a;	// 43
b;	// 42
```

К сожалению, `( )` сами по себе не определяют новое обёрнутое выражение, которое вычисляется следом *за побочным эффектом* выражения `a++`, как мы могли бы надеяться. Фактически, даже если бы это произошло, `a++` сначала возвращает `42`, и, если у вас нет другого выражения, которое повторно вычисляет `a` после побочного эффекта `++`, вы не получите `43` из этого выражения, поэтому `b` не будет присвоен `43`.

Однако есть вариант: `,` - инструкция серии операторов запятой. Этот оператор позволяет вам объединить несколько автономных выражений в одну инструкцию:

```js
var a = 42, b;
b = ( a++, a );

a;	// 43
b;	// 43
```

**Примечание:** Здесь требуется `( .. )` вокруг `a++, a`. Причина в приоритете операторов, о котором мы поговорим позже в этой главе.

Выражение `a++, a` означает, что второе выражение инструкции `a` вычисляется следом *за побочным эффектом* первого выражения инструкции `a++`, что означает, что оно возвращает значение `43` для выполнения присваивания `b`.

Другим примером оператора с побочным действием, является `delete`. Как мы показали в Главе 2, `delete` используется для удаления свойства из `object` или ячейки из `array`. Но обычно он просто вызывается как отдельный оператор:

```js
var obj = {
	a: 42
};

obj.a;			// 42
delete obj.a;	// true
obj.a;			// undefined
```

Результирующее значение оператора `delete` равно `true`, если запрошенная операция является допустимой, или `false` в противном случае. Но побочный эффект оператора заключается в том, что он удаляет свойство объекта (или ячейку массива).

**Примечание:** Что мы подразумеваем под допустимым? Несуществующие свойства или свойства, которые существуют и конфигурируемы (см. Главу 3 из книги этой серии *This и Прототипы Объектов*), вернут `true` из оператора `delete`. В противном случае результат будет `false` или ошибка.

Последним примером оператора с побочным эффектом, который может быть одновременно и очевидным, и неочевидным, является оператор присваивания `=`.

Взгляните:

```js
var a;

a = 42;		// 42
a;			// 42
```

Может показаться, что `=` в инструкции `a = 42` не является оператором с побочным действием. Но, если мы посмотрим на результирующее значение инструкции `a = 42`, то увидим - это только что присвоенное значение (`42`), поэтому присвоение в `a` значения по сути является побочным эффектом.

**Совет:** Те же рассуждения о побочных эффектах применимы к составным операторам присваивания, таким как `+=`, `-=`, и т.д. Например, `a = b += 2` сначала обрабатывается как `b += 2` (то есть `b = b + 2`), а результат *этого* `=` затем присваивается `a`.

Такое поведение, при котором выражение присваивания (или инструкция) завершается присвоенным значением, в первую очередь полезно для цепочек присвоений, таких как:

```js
var a, b, c;

a = b = c = 42;
```

Здесь `c = 42` вычисляется как `42` (с побочным эффектом присваивания `42` в `c`), затем `b = 42` вычисляется как `42` (с побочным эффектом присваивания `42` в `b`), и, наконец, вычисляется `a = 42` (с побочным эффектом присваивания `42` в `a`).

**Предупреждение:** Распространенная ошибка, которую разработчики допускают при выполнении цепочки присваиваний выглядит так: `var a = b = 42`. Хотя это смотрится как одно и то же, но это не так. Если эта инструкция выполняется без наличия отдельной инструкции `var b` (где-то в области видимости), которая официально декларирует переменную `b`, то `var a = b = 42` не объявляет переменную `b` напрямую. В зависимости от `strict` режима это приведёт либо к ошибке, либо к случайной глобальной переменной (см. книгу этой серии *Область Видимости и Замыкания*).

Другой пример для рассмотрения:

```js
function vowels(str) {
	var matches;

	if (str) {
		// выбрать все гласные
		matches = str.match( /[aeiou]/g );

		if (matches) {
			return matches;
		}
	}
}

vowels( "Hello World" ); // ["e","o","o"]
```

Это работает, и многие разработчики предпочитают именно такой вариант. Но мы можем упростить функцию, объединив два оператора `if` в один, если применим идиому, в которой побочный эффект присваивания будет работать на пользу:

```js
function vowels(str) {
	var matches;

	// выбрать все гласные
	if (str && (matches = str.match( /[aeiou]/g ))) {
		return matches;
	}
}

vowels( "Hello World" ); // ["e","o","o"]
```

**Примечание:** `( .. )` вокруг `matches = str.match..` обязательны. Причина - приоритет операторов, который мы рассмотрим позже в разделе "Приоритет операторов" этой главы.

Я предпочитаю этот более короткий стиль, так как он, по-моему, проясняет, что два условных выражения на самом деле связаны, а не разделены. Но, как и в случае с большинством стилистических вариантов в JS, это лишь мнение, какой вариант *лучше*.

### Контекстуальные правила

В правилах грамматики JavaScript есть довольно много мест, где один и тот же синтаксис означает разные вещи в зависимости от того, где / как он используется. Такого рода вещи сами по себе могут вызвать немалую путаницу.

Здесь мы не перечислим исчерпывающе все подобные случаи, а просто назовем несколько самых распространенных.

#### `{ .. }` Фигурные скобки

Есть два основных случая (их будет больше по мере развития JS!), когда в вашем коде появляется пара фигурных скобок `{ .. }`. Давайте взглянем на каждый из них.

##### Объектные литералы

Во-первых, как литерал `object`:

```js
// предположим, что определена функция `bar()`

var a = {
	foo: bar()
};
```

Откуда мы знаем, что это литерал `object`? Потому что пара `{ .. }` - это значение, которое присваивается `a`.

**Примечание:** Эта ссылка `a` называется "L-значение" (значение левой стороны), поскольку она является целью присваивания. Пара `{ .. }` является "R-значением" (значение правой стороны), поскольку она используется *просто* как значение (в данном случае как источник присваивания).

##### Метки

Что произойдет, если мы удалим `var a =` из приведенного выше фрагмента?

```js
// предположим, что определена функция `bar()`

{
	foo: bar()
}
```

Многие разработчики предполагают, что пара `{ .. }` - это просто отдельный литерал `object`, который ничему не присваивается. Но на самом деле все совсем по-другому.

Здесь `{ .. }` - это просто обычный блок кода. В JavaScript не очень идиоматично (тем более в других языках!) иметь такой автономный блок `{ .. }`, но это вполне допустимая грамматика JS. Это может быть особенно полезно в сочетании с объявлениями переменных через `let` с областью видимости блока (см. книгу этой серии *Область Видимости и Замыкания*).

Блок кода `{ .. }` здесь в значительной степени функционально идентичен блоку кода, сопутствующему некой инструкции, такой как циклы `for`/`while`, условного ветвления `if` и т.д.

Но, если это обычный блок кода, тогда, что это за странный синтаксис `foo: bar()` и насколько это корректно?

Этот обескураживающе малоизвестный инструмент в JavaScript называется "инструкцией с меткой". Здесь `foo` - это метка для инструкции `bar()` (у которой опущена завершающая `;` - см. далее в этой главе "Автоматические точки с запятой"). Но в чем смысл инструкции с меткой?

Если бы в JavaScript был оператор `goto`, вы теоретически могли бы написать `goto foo` и заставить перейти сюда, продолжить выполнять код с этого места. Обычно `goto` считаются ужасными идиомами программирования, поскольку они значительно затрудняют понимание кода (он же "спагетти-код"), поэтому *очень хорошо*, что в JavaScript нет привычного `goto`.

Однако JS *действительно* поддерживает ограниченную, специальную форму `goto`: переходы по метке. Обе инструкции `continue` и `break` могут опционально принимать указанную метку, и в этом случае поток программы "прыгает" подобно `goto`. Рассмотрим:

```js
// `foo` labeled-loop
foo: for (var i=0; i<4; i++) {
	for (var j=0; j<4; j++) {
		// всякий раз, когда встречается, продолжить внешний цикл
		if (j == i) {
			// перейти к следующей итерации
			// цикла, помеченного `foo`
			continue foo;
		}

		// пропускать нечетные числа
		if ((j * i) % 2 == 1) {
			// обычный (безметочный) `continue` внутреннего цикла
			continue;
		}

		console.log( i, j );
	}
}
// 1 0
// 2 0
// 2 1
// 3 0
// 3 2
```

**Примечание:** `continue foo` не означает "перейти к позиции с меткой 'foo', чтобы продолжить", а "продолжить цикл с меткой "foo" со следующей итерации". Итак, это *на самом деле* не произвольное `goto`.

Как вы видите, мы пропустили итерацию с нечетным произведением `3 1`, а переход с меткой также пропустил итерации `1 1` и `2 2`.

Возможно, немного более полезная форма перехода с меткой - это `break __` из внутреннего цикла, чтобы выбраться из внешнего цикла. Эту логику довольно громоздко реализовывать с помощью `break` без метки:

```js
// `foo` labeled-loop
foo: for (var i=0; i<4; i++) {
	for (var j=0; j<4; j++) {
		if ((i * j) >= 3) {
			console.log( "останавливаемся!", i, j );
			// прервать цикл помеченный меткой `foo`
			break foo;
		}

		console.log( i, j );
	}
}
// 0 0
// 0 1
// 0 2
// 0 3
// 1 0
// 1 1
// 1 2
// останавливаемся! 1 3
```

**Примечание:** `break foo` не означает "перейти к позиции с меткой 'foo', чтобы продолжить", а "выйти из цикла/блока с надписью 'foo' и продолжить *после* него". Не совсем `goto` в традиционном понимании, да?

Безметочная альтернатива `break` вышеописанному, вероятно, потребовала бы задействовать одну или несколько функций, доступ к переменной из общей области видимости и т.д. Скорее всего, это было бы более запутанным, чем `break` с меткой, поэтому использование `break` с меткой здесь, вероятно, является лучшим вариантом.

Метка может применяться к блоку без цикла, но только `break` может сослаться на такую метку. Вы можете сделать `break ___` из любого блока с меткой, но вы не можете использовать `continue ___` или использовать `break` без метки из блока.

```js
function foo() {
	// блок с меткой `bar`
	bar: {
		console.log( "Привет" );
		break bar;
		console.log( "никогда не выводится" );
	}
	console.log( "Мир" );
}

foo();
// Hello
// World
```

Циклы/блоки с метками крайне редки, и к ним часто относятся неодобрительно. Если это возможно, то лучше всего избегать их; например, используя вызовы функций вместо переходов из цикла. Но, возможно, есть редкие случаи, когда они могут быть полезны. Если вы собираетесь использовать переход по метке, обязательно задокументируйте то, что вы делаете, с подробными объяснениями!

Очень распространено мнение, что JSON является корректным подмножеством JS, поэтому строка JSON (например, `{"a":42}` - обратите внимание на кавычки вокруг имени свойства, как того требует JSON!) считается допустимым кодом JavaScript. **Неправда!** Попробуйте ввести `{"a":42}` в вашу консоль JS, и вы получите сообщение об ошибке.

Инструкция с меткой не может быть заключена в кавычки, поэтому `"a"` не является допустимой меткой, и, следовательно, `:` не может идти сразу после нее.

Итак, JSON действительно является подмножеством синтаксиса JS, но JSON сам по себе не является допустимой грамматикой JS.

Одно из чрезвычайно распространенных заблуждений из этой области заключается в том, что, если бы вы загрузили файл JS через тег `<script src = ..>`, в котором содержится только содержимое JSON (например, результат вызова API), данные были бы прочитаны как действительный JavaScript, но просто были бы недоступны для программы. Обычно заявляют, что JSON-P (практика оборачивания JSON данных в вызов функции, например, `foo({"a":42})`) решает проблему их недоступности, отправляя значение в одну из функций вашей программы.

**Неправда!** Полностью допустимое значение JSON `{"a":42}` само по себе выдало бы ошибку JS, поскольку оно было бы интерпретировано как блок инструкций с недопустимой меткой. Но `foo({"a":42})` является допустимым JS, потому что в нем `{"a":42}` является литеральным значением `object`, передаваемым в `foo (..)`. Итак, правильно сказать, **JSON-P превращает JSON в допустимую JS грамматику**!

##### Блоки

Другая часто цитируемая JS нелепица (связанная с приведением - см. Главу 4) - это:

```js
[] + {}; // "[object Object]"
{} + []; // 0
```

Казалось бы, это говорит, что оператор `+` дает разные результаты в зависимости от того, является ли первый операнд `[]` или `{}`. Но на самом деле это не имеет к оператору никакого отношения!

В первой строке `{}` появляется в выражении оператора `+` и поэтому интерпретируется как фактическое значение (пустой `object`). В главе 4 объясняется, что `[]` преобразуется в `""` и, следовательно, `{}` также преобразуется в значение `string`: `"[object Object]"`.

Но во второй строке `{}` интерпретируется как отдельный пустой блок `{}` (который ничего не делает). Блокам не нужны точки с запятой, так что отсутствие точки с запятой здесь не является проблемой. Наконец, `+ []` - это выражение, которое *явно приводит* `[]` в `number` (см. Главу 4), которое равно `0`.

##### Деструктуризация объекта

Начиная с ES6, есть еще одна ситуация, когда вы увидите пару `{ .. }`, - это "деструктурирующее присваивание" (за дополнительной информацией обратитесь к книге этой серии *ES6 и не только*), в частности, к деструктурированию `object`. Рассмотрим:

```js
function getData() {
	// ..
	return {
		a: 42,
		b: "foo"
	};
}

var { a, b } = getData();

console.log( a, b ); // 42 "foo"
```

Как вы, наверное, можете сказать, `var { a , b } = ..` является формой деструктурирующего присваивания в ES6, что приблизительно эквивалентно:

```js
var res = getData();
var a = res.a;
var b = res.b;
```

**Примечание:** в ES6 `{ a, b }` на самом деле является сокращенной формой деструктурирования `{ a: a, b: b }`, поэтому оба будут работать, но предполагается, что более краткая `{ a, b }` будет предпочтительным вариантом.

Деструктурирование объекта с помощью пары `{ .. }` также может использоваться для именованных аргументов функции, что является сахаром для такого же рода неявного присваивания свойств объекта:

```js
function foo({ a, b, c }) {
	// нет необходимости в:
	// var a = obj.a, b = obj.b, c = obj.c
	console.log( a, b, c );
}

foo( {
	c: [1,2,3],
	a: 42,
	b: "foo"
} );	// 42 "foo" [1, 2, 3]
```

Итак, контекст, в котором мы используем пару `{ .. }`, полностью определяет, что она означает. Это иллюстрирует разницу между синтаксисом и грамматикой. Очень важно понимать эти нюансы, чтобы избежать неожиданных интерпретаций JS движком.

#### `else if` и необязательные блоки

Это распространенное заблуждение, что в JavaScript есть условие `else if`, потому что вы можете сделать так:

```js
if (a) {
	// ..
}
else if (b) {
	// ..
}
else {
	// ..
}
```

Но здесь есть скрытая особенность грамматики JS: здесь нет `else if`. Но инструкциям `if` и `else` разрешается опускать `{ }` вокруг прикрепленного к ним блока, если они содержат только одну инструкцию. Несомненно, ранее вы видели это много раз:

```js
if (a) doSomething( a );
```

Многие руководства по JS стилю будут настаивать на том, чтобы вы всегда использовали `{ }` вокруг блока с единственной инструкцией, например:

```js
if (a) { doSomething( a ); }
```

Однако точно такое же грамматическое правило применяется к условию `else`, поэтому форма `else if`, которую вы, вероятно, всегда писали, *на самом деле* интерпретируется так:

```js
if (a) {
	// ..
}
else {
	if (b) {
		// ..
	}
	else {
		// ..
	}
}
```

`if (b) { .. } else { .. }` - это единственная инструкция, которая следует за `else`, поэтому вы можете либо вставить обрамляющие `{ }`, либо нет. Другими словами, когда вы используете `else if`, вы технически нарушаете общее правило из руководства по стилю и просто определяете свое `else` с помощью одного оператора `if`.

Конечно, идиома `else if` чрезвычайно распространена и приводит к уменьшению отступа на один уровень, поэтому она так привлекательна. Какой бы способ вы ни выбрали, просто пишите явно в своем собственном руководстве по стилю/правилах и не предполагайте, что такие вещи, как `else if`, являются прямыми грамматическими правилами.

## Приоритет оператора

Как мы рассмотрели в Главе 4, `&&` и `||` в Javascript интересны тем, что они выбирают и возвращают один из своих операндов, а не просто приводят к `true` или `false`. Это легко анализировать, если есть только два операнда и один оператор.

```js
var a = 42;
var b = "foo";

a && b;	// "foo"
a || b;	// 42
```

А, если задействованы два оператора и три операнда, что тогда?

```js
var a = 42;
var b = "foo";
var c = [1,2,3];

a && b || c; // ???
a || b && c; // ???
```

Чтобы понять, какой результат этих выражений, нам нужно понять, какие правила регламентируют обработку операторов, когда их в выражении более одного.

Эти правила называются "приоритетом операторов".

Бьюсь об заклад, большинство читателей считают, что они неплохо разбираются в приоритете операторов. Но, как и во всем остальном, что мы рассмотрели в этой серии книг, мы собираемся испытать это понимание на прочность, и, надеемся, узнать новое на этом пути.

Вспомним приведенный выше пример:

```js
var a = 42, b;
b = ( a++, a );

a;	// 43
b;	// 43
```

А какой будет результат, если убрать `( )`?

```js
var a = 42, b;
b = a++, a;

a;	// 43
b;	// 42
```

Погодите! Почему это изменило значение, присвоенное `b`?

Потому что оператор `,` имеет более низкий приоритет, чем оператор `=`. Поэтому, `b = a++, a` интерпретируется как `(b = a++), a`. Поскольку (как мы выяснили ранее) `a++` имеет *пост-побочные эффекты*, `b` присвоено значение `42` до того, как `++` изменит `a`.

Это простейший пример необходимости понимать приоритет оператора. Если вы планируете использовать `,` в качестве инструкции серии операторов, то важно знать, что он имеет наименьший приоритет. Любой другой оператор будет использован раньше, чем `,`.

Теперь вспомним другой рассмотренный ранее пример:

```js
if (str && (matches = str.match( /[aeiou]/g ))) {
	// ..
}
```

Мы говорили, что `( )` вокруг присваивания обязательны, но почему? Потому что `&&` имеет более высокий приоритет, чем `=`. Поэтому без принудительной группировки `( )` выражение интерпретировалось бы как `(str && matches) = str.match..`. И это инициировало бы ошибку, потому что результат `(str && matches)` будет не переменной, а значением (в данном случае `undefined`), и поэтому оно не может быть левой частью присваивания `=`!

Хорошо, итак, вы, вероятно, думаете, что эта проблема с приоритетом оператора у вас решена.

Тогда, давайте перейдем к более сложному примеру (который мы рассмотрим в следующих разделах этой главы), чтобы *действительно* проверить ваше понимание:

```js
var a = 42;
var b = "foo";
var c = false;

var d = a && b || c ? c || b ? a : c && b : a;

d;		// ??
```

Ладно, я признаю, - это зло. Никто не стал бы писать подобную строку набора инструкций, верно? *Вероятно*, нет, но мы используем её для изучения различных проблем, связанных с объединением нескольких операторов в цепочку, что *является* очень распространенной задачей.

Результат выражения выше равен `42`. Но это не так интересно, как то, как мы нашли ответ, не запуская JS программу, дав ей его посчитать.

Давайте копнём.

Первый вопрос - который вам, возможно, даже не пришёл в голову - в том, ведет ли себя первая часть (`a && b || c`) как `(a && b) || c` или как `a && (b || c)`? Вы уверены? Можете ли вы хотя бы себя убедить, что они действительно разные?

```js
(false && true) || true;	// true
false && (true || true);	// false
```

Итак, доказано, что они разные. И все же, как ведет себя `false && true || true`? Ответ:

```js
false && true || true;		// true
(false && true) || true;	// true
```

Теперь у нас есть ответ. Оператор `&&` вычисляется первым, а оператор `||` вычисляется вторым.

Но вызвано ли это обработкой слева направо? Давайте поменяем порядок операторов на обратный:

```js
true || false && false;		// true

(true || false) && false;	// false -- нет
true || (false && false);	// true -- победитель!
```

Теперь мы доказали, что сначала вычисляется `&&`, а затем `||`, и в данном случае это шло явно в разрез с привычно ожидаемой обработкой слева направо.

Так что же вызвало такое поведение? **Приоритет оператора**.

Каждый язык определяет свой список приоритетов операторов. То, насколько уникален он, приводит в отчаяние, так как JS разработчикам приходится лезть в него и читать.

Если бы вы хорошо его знали, то приведенные выше примеры ничуть не сбили бы вас с толку, потому что вы бы уже знали, что `&&` более приоритетен, чем `||`. Но, я уверен, изрядному числу читателей пришлось задуматься над этим.

**Примечание:** К сожалению, в спецификации JS нет списка приоритетов операторов в одном удобном списке. Вы должны прошерстить и понять все правила грамматики. Поэтому мы постараемся описать здесь наиболее типичные и полезные ситуации в более удобной подаче. Полный список приоритетов операторов см. в разделе "Приоритет операторов" на сайте MDN *(https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)*.

### Короткий цикл вычислений

В дополнительном примечании Главы 4 мы упоминали о "коротком цикле вычислений" (short circuiting) таких операторов, как `&&` и `||`. Давайте вернемся к нему более подробно.

Для обоих операторов `&&` и `||` правый операнд **не будет вычислен**, если для определения результата операции достаточно левого операнда. Отсюда и название "короткий цикл" (в том смысле, что возможно досрочное завершение).

Например, в `a && b` значение `b` не вычисляется, если `a` ложное, потому что результат операнда `&&` уже понятен, и нет смысла беспокоиться о проверке `b`. Аналогично, с `a || b`, если `a` правдиво, результат операнда также понятен, и нет резона проверять `b`.

Этот короткий цикл бывает очень полезным и широко используется:

```js
function doSomething(opts) {
	if (opts && opts.cool) {
		// ..
	}
}
```

`opts` в проверке `opts && opts.cool` действует как предохранитель, потому что, если `opts` не установлен (или не `object`), то `opts.cool` выдаст ошибку. При отрицательном результате проверки `opts` короткий цикл отменит проверку `opts.cool`, и никакой ошибки не возникнет!

Аналогично, вы можете использовать короткий цикл `||`:

```js
function doSomething(opts) {
	if (opts.cache || primeCache()) {
		// ..
	}
}
```

Здесь мы сначала проверяем наличие `opts.cache`, и если он есть, то не вызываем функцию `prime Cache()`, избегая таким образом потенциально лишней работы.

### Более тесная связка

Но давайте вновь обратим наше внимание на тот предыдущий пример инструкции с цепочкой операторов, в частности на тернарные операторы `? :`. Имеет ли оператор `? :` больший или меньший приоритет, чем `&&` и `||`?

```js
a && b || c ? c || b ? a : c && b : a
```

Идентичен ли он этому:

```js
a && b || (c ? c || (b ? a : c) && b : a)
```

или этому?

```js
(a && b || c) ? (c || b) ? a : (c && b) : a
```

Правильный ответ второй. Но почему?

Потому что `&&` более приоритетный, чем `||`, а `||` более приоритетный, чем `? :`.

Поэтому *первым* вычисляется выражение `(a && b || c)`, а затем `? :`, частью которого он является. Другой популярный вариант объяснения следующий: `&&` и `||` "более тесно связаны", чем `? :`. Если бы было верно обратное, то `c ? c...` было бы более тесно связано, и работал бы первый вариант - `a && b || (c ? c..)`.

### Ассоциативность

Итак, сначала группируются `&&` и `||`, затем оператор `? :`. Но как быть в ситуации нескольких операторов с одинаковым приоритетом? Обрабатываются ли они всегда слева направо или справа налево?

Операторы обычно бывают либо левоассоциативными, либо правоассоциативными, в зависимости от этого **группировка выполняется слева или справа**.

Важно отметить, что ассоциативность - это *не* то же самое, что обработка слева направо или справа налево.

Почему же тогда так важно, выполняется ли обработка слева направо или справа налево? Потому что выражения могут иметь побочные эффекты, как, например, при вызове функций:

```js
var a = foo() && bar();
```

Здесь сначала вычисляется `foo()`, а затем в зависимости от результата `foo()`, возможно, `bar()`. Это безусловно могло бы сказаться на поведении программы, если бы `bar()` вызывался перед `foo()`.

Но здесь обработка идет *просто* слева направо (поведение по умолчанию в JavaScript!) - здесь не важна ассоциативность `&&`. Поскольку в этом примере есть только одно `&&`, то, следовательно, здесь нет места группировке, ассоциативность даже не вступает в игру.

Однако в выражении `a && b && c` группировка *будет* происходить неявно, что означает, что сначала будет вычислено либо `a && b`, либо `b && c`.

Технически `a && b && c` будет обрабатываться как `(a && b) && c`, потому что `&&` является левоассоциативным (как и `||`, кстати). Однако правоассоциативная альтернатива `a && (b && c)` ведет себя, очевидно, точно также. Для одних и тех же значений одни и те же выражения вычисляются в одном и том же порядке.

**Примечание:** Гипотетически, если бы `&&` был правоассоциативным, он был бы обработан аналогично ручной группировке `a && (b && c)`. Но это все еще **не означает**, что `c` будет вычислен перед `b`. Правая ассоциативность **не означает** вычисления справа налево, это означает **группировку** справа налево. В любом случае, независимо от группировки / ассоциативности, строгий порядок вычисления будет `a`, затем `b`, затем `c` (то есть слева направо).

Поэтому не так уж важно, что `&&` и `||` являются левоассоциативными, кроме как для точности обсуждаемых определений.

Но это не всегда так. Некоторые операторы будут вести себя очень по-разному в зависимости от лево- и правоассоциативности.

Рассмотрим `? :` ("тернарный" или "условный") оператор:

```js
a ? b : c ? d : e;
```

`? :` является правоассоциативным. Итак, какая группировка соответствует очерёдности выполнения?

* `a ? b : (c ? d : e)`
* `(a ? b : c) ? d : e`

Ответ таков: `a ? b : (c ? d : e)`. В отличие от `&&` и `||` выше, правая ассоциативность здесь действительно имеет значение, поскольку `(a ? b : c) ? d : e` *будет* вести себя по-разному для некоторых (но не для всех!) комбинаций значений.

Один из таких примеров:

```js
true ? false : true ? true : true;		// false

true ? false : (true ? true : true);	// false
(true ? false : true) ? true : true;	// true
```

Еще более тонкие различия скрываются в других комбинациях значений, даже если конечный результат тот же. Взглянем:

```js
true ? false : true ? true : false;		// false

true ? false : (true ? true : false);	// false
(true ? false : true) ? true : false;	// false
```

В этом случае одинаковые результаты сеют сомнения, какой вариант группировки действует. Однако:

```js
var a = true, b = false, c = true, d = true, e = false;

a ? b : (c ? d : e); // false, вычисляются только `a` и `b`
(a ? b : c) ? d : e; // false, вычисляются `a`, `b` и `e`
```

Итак, мы четко доказали, что `? :` является правоассоциативным, и что это действительно имеет значение в отношении того, как ведет себя оператор в цепочке с самим собой.

Другим примером правой ассоциативности (группировки) является оператор `=`. Вспомните пример с цепочкой присваивания, рассмотренный выше в этой главе:

```js
var a, b, c;

a = b = c = 42;
```

Ранее мы сказали, что обработка `a = b = c = 42` ведётся, начиная с присваивания `c = 42`, затем `b = ..` и, наконец, `a = ..`. Почему? Из-за правой ассоциативности, которая на самом деле трактует инструкцию следующим образом: `a = (b = (c = 42))`.

Помните наш первый пример присваивания сложного выражения в этой главе?

```js
var a = 42;
var b = "foo";
var c = false;

var d = a && b || c ? c || b ? a : c && b : a;

d;		// 42
```

Вооружившись нашими знаниями о приоритете и ассоциативности, мы теперь способны разбить код на группы, описывающие обработку этой инструкции:

```js
((a && b) || c) ? ((c || b) ? a : (c && b)) : a
```

Или с отступами, если это легче понять:

```js
(
  (a && b)
    ||
  c
)
  ?
(
  (c || b)
    ?
  a
    :
  (c && b)
)
  :
a
```

Давайте решим это сейчас:

1. `(a && b)` равно `"foo"`.
2. `"foo" || c` равно `"foo"`.
3. В первом `?` проверка `"foo"` правдивая.
4. `(c || b)` равно `"foo"`.
5. Во втором `?` проверка `"foo"` правдивая.
6. `a` равно `42`.

Вот и все, мы закончили! Ответ - `42`, как и раньше. На самом деле это было не так уж трудно, не правда ли?

### Избежание двусмысленностей

Теперь вы гораздо лучше понимаете ассоциативность и приоритеты операторов, и чувствуете себя увереннее, понимая, как будет вести себя код с цепочкой операторов.

Но остается важный вопрос: должны ли мы все писать код, понимая и исключительно полагаясь на все правила ассоциативности / приоритета операторов? Следует ли нам использовать ручную группировку `( )` лишь тогда, когда необходимо применить другой порядок обработки?

Или, с другой стороны, принимая, что, хотя эти правила *на самом деле* поддаются изучению, но тут достаточно ловушек, чтобы не полагаться на автоматические приоритеты и ассоциативности? Если да, то должны ли мы тогда, всегда использовать ручную группировку `( )` и полностью отказаться от заложенного механизма поведения?

Эта дискуссия в высшей степени субъективна и аналогична дискуссии в Главе 4 о *неявном* приведении. Большинство разработчиков исповедуют единый подход в обоих случаях: либо они принимают оба варианта поведения и код, ожидающий их, либо они отбрасывают оба варианта поведения и придерживаются ручных / явных идиом.

Конечно, тут я не могу ответить читателю на вопрос более однозначно, чем в Главе 4. Но я показал вам плюсы и минусы и, надеюсь, помог достаточно глубоко понять тему, чтобы вы могли принять обоснованное, а не продиктованное ажиотажем решение.

На мой взгляд, есть важная золотая середина. Нам следует использовать *и* приоритет операторов/ассоциативность, *и* ручную группировку `( )` в нашем коде. Той же подход я предлагал в Главе 4, выступая за здоровое/безопасное использование *неявного* приведения, и против его повсеместного применения.

Например, `if (a && b && c) ..` для меня норма, и я не стал бы писать `if ((a && b) && c) ..`, чтобы явно задать ассоциативность, потому что я думаю, это излишне.

С другой стороны, если бы мне нужно было связать два оператора `? :` вместе, я бы, конечно, использовал ручную группировку `( )`, чтобы было абсолютно ясно, какую логику я заложил здесь.

Таким образом, мой совет здесь аналогичен совету из Главы 4: **используйте приоритет операторов/ассоциативность там, где это приводит к более короткому и чистому коду, но используйте ручную группировку `( )` там, где это вносит ясность и уменьшает путаницу**.

## Автоматическая расстановка точки с запятой

ASI (автоматическая вставка точки с запятой) - это когда JavaScript подразумевает `;` в определенных местах вашей JS-программы, даже если вы её туда не ставили.

Зачем ему это делать? Потому что, если вы опустите хотя бы одну обязательную `;`, ваша программа завершится сбоем. Не всегда всепрощающе. ASI позволяет JS быть терпимым к определенным местам, где обычно `;` не считается необходимой.

Важно отметить, что ASI работает только при наличии новой строки (она же разрыв строки). Точки с запятой не вставляются в середину строки.

По существу, если JS-парсер анализирует строку, в которой произошла бы ошибка синтаксического анализа (ожидаемое отсутствие `;`), и он может разумно вставить ее, он это делает. Что разумно для вставки? Только если между концом какого-либо оператора и новой строкой/разрывом строки нет ничего, кроме пробелов и/или комментариев.

Рассмотрим:

```js
var a = 42, b
c;
```

Должен ли JS рассматривать `c` в следующей строке как часть инструкции `var`? Это, конечно, так и было бы, если бы где-нибудь была `,` (даже в другой строке) между `b` и `c`. Но поскольку её нет, JS вместо этого предполагает, что после `b` есть подразумеваемая `;` (в новой строке). Таким образом, `c;` остается как отдельный оператор выражения.

Аналогично:

```js
var a = 42, b = "foo";

a
b	// "foo"
```

Это все еще допустимая программа без ошибок, потому что выражения также признают действие ASI.

Есть определенные места, где ASI полезен, например:

```js
var a = 42;

do {
	// ..
} while (a)	// <-- ; ожидается здесь!
a;
```

Грамматика требует `;` после цикла `do..while`, но не после циклов `while` или `for`. Однако большинство разработчиков этого не помнит! Поэтому ASI услужливо вмешивается и вставляет её.

Как мы говорили ранее в этой главе, блоки операторов не требуют завершающей `;`, поэтому в ASI нет необходимости:

```js
var a = 42;

while (a) {
	// ..
} // <-- ; не ожидается здесь.
a;
```

Другой важный случай, когда ASI срабатывает, - это ключевые слова `break`, `continue`, `return` и (ES6) `yield`:

```js
function foo(a) {
	if (!a) return
	a *= 2;
	// ..
}
```

Оператор `return` не включает выражение следующей строки `a *= 2`, поскольку ASI предполагает завершающую `;` у оператора `return`. Конечно, операторы `return` *можно* легко разбивать на несколько строк, но только не тогда, когда после `return` ничего нет, кроме новой строки/разрыва строки.

```js
function foo(a) {
	return (
		a * 2 + 3 / 12
	);
}
```

Аналогичные рассуждения применимы к `break`, `continue` и `yield`.

### Исправление ошибок

Одна из самых горячих *религиозных войн* JS-сообщества (помимо табуляции и пробелов) ведётся о том, следует ли сильно/исключительно полагаться на ASI или нет.

Большинство точек с запятой необязательны, но не все. Две `;` требуется в заголовок цикла `for ( .. ) ..`.

На стороне сторонников многие разработчики считают, что ASI - это полезный механизм, который позволяет им писать более лаконичный (и более "красивый") код, опуская все, кроме строго обязательных `;` (которых очень мало). Часто утверждается, что ASI делает многие `;` необязательными, поэтому правильно написанная программа *без них* ничем не отличается от правильно написанной программы *с ними*.

Из стана противников многие разработчики говорят, что существует *слишком много* мест, способных стать источниками случайных ошибок, особенно для молодых, менее опытных разработчиков, где непреднамеренная, вставленная волшебным образом `;` меняет смысл. Аналогично, некоторые разработчики утверждают, что, если они опускают точку с запятой, это явная ошибка, и они хотят, чтобы их инструменты (линтеры и т.д.) обнаружили ее до того, как движок JS *исправит* ошибку под капотом.

Позвольте мне просто поделиться своей точкой зрения. Строгое прочтение спецификации подразумевает, что ASI - это процедура "исправления ошибок". Что это за ошибка, спросите вы? В частности, ошибка **синтаксического анализатора**. Другими словами, в попытке уменьшить количество сбоев парсера ASI позволяет ему быть более терпимым.

Но терпимый к чему? На мой взгляд, единственная причина возникновения ошибки **синтаксического анализа** - это если для анализа дана неправильная программа с ошибками. Таким образом, хотя ASI строго исправляет ошибки синтаксического анализатора, единственный способ получить такие ошибки - это ошибки автора программы - пропуск точек с запятой там, где этого требуют правила грамматики.

Итак, честно говоря, когда я слышу, как кто-то утверждает, что они хотят опустить "необязательные точки с запятой", мой мозг переводит это утверждение в "Я хочу написать максимально неправильную для синтаксического анализатора программу, которая все же будет работать".

Я нахожу это нелепым, а аргументы в пользу сокращения нажатий клавиш и получения более "красивого кода" в лучшем случае слабыми.

Более того, я не согласен с тем, что это то же самое, что дебаты о пробелах и табуляциях - что это лишь вопрос оформления. Я считаю, это фундаментальный вопрос: написание кода, соответствующего требованиям грамматики, или код, который полагается на грамматические исключения, чтобы только-только пройти проверку.

Ещё один взгляд на проблему в том, что полагаться на ASI - это, по сути, рассматривать новые строки как значимые "пробелы". Другие языки, такие как Python, имеют действительно значимые пробелы. Но уместно ли думать о JavaScript как о языке, имеющем значимые новые строки в том виде, в каком он существует сегодня?

Мое мнение: **используйте точки с запятой везде, где вы знаете, что они "обязательны", и по минимуму полагайтесь на ASI**.

Однако не верьте мне на слово. Еще в 2012 году создатель JavaScript Брендан Эйх сказал (http://brendaneich.com/2012/04/the-infernal-semicolon /) следующее:

> Мораль этой истории: ASI - это (формально говоря) процедура исправления синтаксических ошибок. Если вы начнете кодировать так, как если бы это было универсальное правило - значимых новый строк, то у вас будут проблемы.
> ..
> Жаль, что я не сделал новые строки более значимыми в JS в те десять дней мая 1995 года.
> ..
> Будьте осторожны, не используйте ASI так, как если бы у JS новые строки значимы.

### Error Correction

One of the most hotly contested *religious wars* in the JS community (besides tabs vs. spaces) is whether to rely heavily/exclusively on ASI or not.

Most, but not all, semicolons are optional, but the two `;`s in the `for ( .. ) ..` loop header are required.

On the pro side of this debate, many developers believe that ASI is a useful mechanism that allows them to write more terse (and more "beautiful") code by omitting all but the strictly required `;`s (which are very few). It is often asserted that ASI makes many `;`s optional, so a correctly written program *without them* is no different than a correctly written program *with them*.

On the con side of the debate, many other developers will assert that there are *too many* places that can be accidental gotchas, especially for newer, less experienced developers, where unintended `;`s being magically inserted change the meaning. Similarly, some developers will argue that if they omit a semicolon, it's a flat-out mistake, and they want their tools (linters, etc.) to catch it before the JS engine *corrects* the mistake under the covers.

Let me just share my perspective. A strict reading of the spec implies that ASI is an "error correction" routine. What kind of error, you may ask? Specifically, a **parser error**. In other words, in an attempt to have the parser fail less, ASI lets it be more tolerant.

But tolerant of what? In my view, the only way a **parser error** occurs is if it's given an incorrect/errored program to parse. So, while ASI is strictly correcting parser errors, the only way it can get such errors is if there were first program authoring errors -- omitting semicolons where the grammar rules require them.

So, to put it more bluntly, when I hear someone claim that they want to omit "optional semicolons," my brain translates that claim to "I want to write the most parser-broken program I can that will still work."

I find that to be a ludicrous position to take and the arguments of saving keystrokes and having more "beautiful code" to be weak at best.

Furthermore, I don't agree that this is the same thing as the spaces vs tabs debate -- that it's purely cosmetic -- but rather I believe it's a fundamental question of writing code that adheres to grammar requirements vs. code that relies on grammar exceptions to just barely skate through.

Another way of looking at it is that relying on ASI is essentially considering newlines to be significant "whitespace." Other languages like Python have true significant whitespace. But is it really appropriate to think of JavaScript as having significant newlines as it stands today?

My take: **use semicolons wherever you know they are "required," and limit your assumptions about ASI to a minimum.**

But don't just take my word for it. Back in 2012, creator of JavaScript Brendan Eich said (http://brendaneich.com/2012/04/the-infernal-semicolon/) the following:

> The moral of this story: ASI is (formally speaking) a syntactic error correction procedure. If you start to code as if it were a universal significant-newline rule, you will get into trouble.
> ..
> I wish I had made newlines more significant in JS back in those ten days in May, 1995.
> ..
> Be careful not to use ASI as if it gave JS significant newlines.

## Errors

Not only does JavaScript have different *subtypes* of errors (`TypeError`, `ReferenceError`, `SyntaxError`, etc.), but also the grammar defines certain errors to be enforced at compile time, as compared to all other errors that happen during runtime.

In particular, there have long been a number of specific conditions that should be caught and reported as "early errors" (during compilation). Any straight-up syntax error is an early error (e.g., `a = ,`), but also the grammar defines things that are syntactically valid but disallowed nonetheless.

Since execution of your code has not begun yet, these errors are not catchable with `try..catch`; they will just fail the parsing/compilation of your program.

**Tip:** There's no requirement in the spec about exactly how browsers (and developer tools) should report errors. So you may see variations across browsers in the following error examples, in what specific subtype of error is reported or what the included error message text will be.

One simple example is with syntax inside a regular expression literal. There's nothing wrong with the JS syntax here, but the invalid regex will throw an early error:

```js
var a = /+foo/;		// Error!
```

The target of an assignment must be an identifier (or an ES6 destructuring expression that produces one or more identifiers), so a value like `42` in that position is illegal and can be reported right away:

```js
var a;
42 = a;		// Error!
```

ES5's `strict` mode defines even more early errors. For example, in `strict` mode, function parameter names cannot be duplicated:

```js
function foo(a,b,a) { }					// just fine

function bar(a,b,a) { "use strict"; }	// Error!
```

Another `strict` mode early error is an object literal having more than one property of the same name:

```js
(function(){
	"use strict";

	var a = {
		b: 42,
		b: 43
	};			// Error!
})();
```

**Note:** Semantically speaking, such errors aren't technically *syntax* errors but more *grammar* errors -- the above snippets are syntactically valid. But since there is no `GrammarError` type, some browsers use `SyntaxError` instead.

### Using Variables Too Early

ES6 defines a (frankly confusingly named) new concept called the TDZ ("Temporal Dead Zone").

The TDZ refers to places in code where a variable reference cannot yet be made, because it hasn't reached its required initialization.

The most clear example of this is with ES6 `let` block-scoping:

```js
{
	a = 2;		// ReferenceError!
	let a;
}
```

The assignment `a = 2` is accessing the `a` variable (which is indeed block-scoped to the `{ .. }` block) before it's been initialized by the `let a` declaration, so it's in the TDZ for `a` and throws an error.

Interestingly, while `typeof` has an exception to be safe for undeclared variables (see Chapter 1), no such safety exception is made for TDZ references:

```js
{
	typeof a;	// undefined
	typeof b;	// ReferenceError! (TDZ)
	let b;
}
```

## Function Arguments

Another example of a TDZ violation can be seen with ES6 default parameter values (see the *ES6 & Beyond* title of this series):

```js
var b = 3;

function foo( a = 42, b = a + b + 5 ) {
	// ..
}
```

The `b` reference in the assignment would happen in the TDZ for the parameter `b` (not pull in the outer `b` reference), so it will throw an error. However, the `a` in the assignment is fine since by that time it's past the TDZ for parameter `a`.

When using ES6's default parameter values, the default value is applied to the parameter if you either omit an argument, or you pass an `undefined` value in its place:

```js
function foo( a = 42, b = a + 1 ) {
	console.log( a, b );
}

foo();					// 42 43
foo( undefined );		// 42 43
foo( 5 );				// 5 6
foo( void 0, 7 );		// 42 7
foo( null );			// null 1
```

**Note:** `null` is coerced to a `0` value in the `a + 1` expression. See Chapter 4 for more info.

From the ES6 default parameter values perspective, there's no difference between omitting an argument and passing an `undefined` value. However, there is a way to detect the difference in some cases:

```js
function foo( a = 42, b = a + 1 ) {
	console.log(
		arguments.length, a, b,
		arguments[0], arguments[1]
	);
}

foo();					// 0 42 43 undefined undefined
foo( 10 );				// 1 10 11 10 undefined
foo( 10, undefined );	// 2 10 11 10 undefined
foo( 10, null );		// 2 10 null 10 null
```

Even though the default parameter values are applied to the `a` and `b` parameters, if no arguments were passed in those slots, the `arguments` array will not have entries.

Conversely, if you pass an `undefined` argument explicitly, an entry will exist in the `arguments` array for that argument, but it will be `undefined` and not (necessarily) the same as the default value that was applied to the named parameter for that same slot.

While ES6 default parameter values can create divergence between the `arguments` array slot and the corresponding named parameter variable, this same disjointedness can also occur in tricky ways in ES5:

```js
function foo(a) {
	a = 42;
	console.log( arguments[0] );
}

foo( 2 );	// 42 (linked)
foo();		// undefined (not linked)
```

If you pass an argument, the `arguments` slot and the named parameter are linked to always have the same value. If you omit the argument, no such linkage occurs.

But in `strict` mode, the linkage doesn't exist regardless:

```js
function foo(a) {
	"use strict";
	a = 42;
	console.log( arguments[0] );
}

foo( 2 );	// 2 (not linked)
foo();		// undefined (not linked)
```

It's almost certainly a bad idea to ever rely on any such linkage, and in fact the linkage itself is a leaky abstraction that's exposing an underlying implementation detail of the engine, rather than a properly designed feature.

Use of the `arguments` array has been deprecated (especially in favor of ES6 `...` rest parameters -- see the *ES6 & Beyond* title of this series), but that doesn't mean that it's all bad.

Prior to ES6, `arguments` is the only way to get an array of all passed arguments to pass along to other functions, which turns out to be quite useful. You can also mix named parameters with the `arguments` array and be safe, as long as you follow one simple rule: **never refer to a named parameter *and* its corresponding `arguments` slot at the same time.** If you avoid that bad practice, you'll never expose the leaky linkage behavior.

```js
function foo(a) {
	console.log( a + arguments[1] ); // safe!
}

foo( 10, 32 );	// 42
```

## `try..finally`

You're probably familiar with how the `try..catch` block works. But have you ever stopped to consider the `finally` clause that can be paired with it? In fact, were you aware that `try` only requires either `catch` or `finally`, though both can be present if needed.

The code in the `finally` clause *always* runs (no matter what), and it always runs right after the `try` (and `catch` if present) finish, before any other code runs. In one sense, you can kind of think of the code in a `finally` clause as being in a callback function that will always be called regardless of how the rest of the block behaves.

So what happens if there's a `return` statement inside a `try` clause? It obviously will return a value, right? But does the calling code that receives that value run before or after the `finally`?

```js
function foo() {
	try {
		return 42;
	}
	finally {
		console.log( "Hello" );
	}

	console.log( "never runs" );
}

console.log( foo() );
// Hello
// 42
```

The `return 42` runs right away, which sets up the completion value from the `foo()` call. This action completes the `try` clause and the `finally` clause immediately runs next. Only then is the `foo()` function complete, so that its completion value is returned back for the `console.log(..)` statement to use.

The exact same behavior is true of a `throw` inside `try`:

```js
 function foo() {
	try {
		throw 42;
	}
	finally {
		console.log( "Hello" );
	}

	console.log( "never runs" );
}

console.log( foo() );
// Hello
// Uncaught Exception: 42
```

Now, if an exception is thrown (accidentally or intentionally) inside a `finally` clause, it will override as the primary completion of that function. If a previous `return` in the `try` block had set a completion value for the function, that value will be abandoned.

```js
function foo() {
	try {
		return 42;
	}
	finally {
		throw "Oops!";
	}

	console.log( "never runs" );
}

console.log( foo() );
// Uncaught Exception: Oops!
```

It shouldn't be surprising that other nonlinear control statements like `continue` and `break` exhibit similar behavior to `return` and `throw`:

```js
for (var i=0; i<10; i++) {
	try {
		continue;
	}
	finally {
		console.log( i );
	}
}
// 0 1 2 3 4 5 6 7 8 9
```

The `console.log(i)` statement runs at the end of the loop iteration, which is caused by the `continue` statement. However, it still runs before the `i++` iteration update statement, which is why the values printed are `0..9` instead of `1..10`.

**Note:** ES6 adds a `yield` statement, in generators (see the *Async & Performance* title of this series) which in some ways can be seen as an intermediate `return` statement. However, unlike a `return`, a `yield` isn't complete until the generator is resumed, which means a `try { .. yield .. }` has not completed. So an attached `finally` clause will not run right after the `yield` like it does with `return`.

A `return` inside a `finally` has the special ability to override a previous `return` from the `try` or `catch` clause, but only if `return` is explicitly called:

```js
function foo() {
	try {
		return 42;
	}
	finally {
		// no `return ..` here, so no override
	}
}

function bar() {
	try {
		return 42;
	}
	finally {
		// override previous `return 42`
		return;
	}
}

function baz() {
	try {
		return 42;
	}
	finally {
		// override previous `return 42`
		return "Hello";
	}
}

foo();	// 42
bar();	// undefined
baz();	// "Hello"
```

Normally, the omission of `return` in a function is the same as `return;` or even `return undefined;`, but inside a `finally` block the omission of `return` does not act like an overriding `return undefined`; it just lets the previous `return` stand.

In fact, we can really up the craziness if we combine `finally` with labeled `break` (discussed earlier in the chapter):

```js
function foo() {
	bar: {
		try {
			return 42;
		}
		finally {
			// break out of `bar` labeled block
			break bar;
		}
	}

	console.log( "Crazy" );

	return "Hello";
}

console.log( foo() );
// Crazy
// Hello
```

But... don't do this. Seriously. Using a `finally` + labeled `break` to effectively cancel a `return` is doing your best to create the most confusing code possible. I'd wager no amount of comments will redeem this code.

## `switch`

Let's briefly explore the `switch` statement, a sort-of syntactic shorthand for an `if..else if..else..` statement chain.

```js
switch (a) {
	case 2:
		// do something
		break;
	case 42:
		// do another thing
		break;
	default:
		// fallback to here
}
```

As you can see, it evaluates `a` once, then matches the resulting value to each `case` expression (just simple value expressions here). If a match is found, execution will begin in that matched `case`, and will either go until a `break` is encountered or until the end of the `switch` block is found.

That much may not surprise you, but there are several quirks about `switch` you may not have noticed before.

First, the matching that occurs between the `a` expression and each `case` expression is identical to the `===` algorithm (see Chapter 4). Often times `switch`es are used with absolute values in `case` statements, as shown above, so strict matching is appropriate.

However, you may wish to allow coercive equality (aka `==`, see Chapter 4), and to do so you'll need to sort of "hack" the `switch` statement a bit:

```js
var a = "42";

switch (true) {
	case a == 10:
		console.log( "10 or '10'" );
		break;
	case a == 42:
		console.log( "42 or '42'" );
		break;
	default:
		// never gets here
}
// 42 or '42'
```

This works because the `case` clause can have any expression (not just simple values), which means it will strictly match that expression's result to the test expression (`true`). Since `a == 42` results in `true` here, the match is made.

Despite `==`, the `switch` matching itself is still strict, between `true` and `true` here. If the `case` expression resulted in something that was truthy but not strictly `true` (see Chapter 4), it wouldn't work. This can bite you if you're for instance using a "logical operator" like `||` or `&&` in your expression:

```js
var a = "hello world";
var b = 10;

switch (true) {
	case (a || b == 10):
		// never gets here
		break;
	default:
		console.log( "Oops" );
}
// Oops
```

Since the result of `(a || b == 10)` is `"hello world"` and not `true`, the strict match fails. In this case, the fix is to force the expression explicitly to be a `true` or `false`, such as `case !!(a || b == 10):` (see Chapter 4).

Lastly, the `default` clause is optional, and it doesn't necessarily have to come at the end (although that's the strong convention). Even in the `default` clause, the same rules apply about encountering a `break` or not:

```js
var a = 10;

switch (a) {
	case 1:
	case 2:
		// never gets here
	default:
		console.log( "default" );
	case 3:
		console.log( "3" );
		break;
	case 4:
		console.log( "4" );
}
// default
// 3
```

**Note:** As discussed previously about labeled `break`s, the `break` inside a `case` clause can also be labeled.

The way this snippet processes is that it passes through all the `case` clause matching first, finds no match, then goes back up to the `default` clause and starts executing. Since there's no `break` there, it continues executing in the already skipped over `case 3` block, before stopping once it hits that `break`.

While this sort of round-about logic is clearly possible in JavaScript, there's almost no chance that it's going to make for reasonable or understandable code. Be very skeptical if you find yourself wanting to create such circular logic flow, and if you really do, make sure you include plenty of code comments to explain what you're up to!

## Review

JavaScript grammar has plenty of nuance that we as developers should spend a little more time paying closer attention to than we typically do. A little bit of effort goes a long way to solidifying your deeper knowledge of the language.

Statements and expressions have analogs in English language -- statements are like sentences and expressions are like phrases. Expressions can be pure/self-contained, or they can have side effects.

The JavaScript grammar layers semantic usage rules (aka context) on top of the pure syntax. For example, `{ }` pairs used in various places in your program can mean statement blocks, `object` literals, (ES6) destructuring assignments, or (ES6) named function arguments.

JavaScript operators all have well-defined rules for precedence (which ones bind first before others) and associativity (how multiple operator expressions are implicitly grouped). Once you learn these rules, it's up to you to decide if precedence/associativity are *too implicit* for their own good, or if they will aid in writing shorter, clearer code.

ASI (Automatic Semicolon Insertion) is a parser-error-correction mechanism built into the JS engine, which allows it under certain circumstances to insert an assumed `;` in places where it is required, was omitted, *and* where insertion fixes the parser error. The debate rages over whether this behavior implies that most `;` are optional (and can/should be omitted for cleaner code) or whether it means that omitting them is making mistakes that the JS engine merely cleans up for you.

JavaScript has several types of errors, but it's less known that it has two classifications for errors: "early" (compiler thrown, uncatchable) and "runtime" (`try..catch`able). All syntax errors are obviously early errors that stop the program before it runs, but there are others, too.

Function arguments have an interesting relationship to their formal declared named parameters. Specifically, the `arguments` array has a number of gotchas of leaky abstraction behavior if you're not careful. Avoid `arguments` if you can, but if you must use it, by all means avoid using the positional slot in `arguments` at the same time as using a named parameter for that same argument.

The `finally` clause attached to a `try` (or `try..catch`) offers some very interesting quirks in terms of execution processing order. Some of these quirks can be helpful, but it's possible to create lots of confusion, especially if combined with labeled blocks. As always, use `finally` to make code better and clearer, not more clever or confusing.

The `switch` offers some nice shorthand for `if..else if..` statements, but beware of many common simplifying assumptions about its behavior. There are several quirks that can trip you up if you're not careful, but there's also some neat hidden tricks that `switch` has up its sleeve!
